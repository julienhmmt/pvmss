{{define "console"}}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{.Title}}</title>
    <link rel="stylesheet" href="/css/bulma.min.css">
    <link rel="stylesheet" href="/css/base.css">
    <link rel="stylesheet" href="/css/components.css">
    <link rel="stylesheet" href="/css/fontawesome.min.css">
    <style>
        .console-container {
            height: calc(100vh - 60px);
            display: flex;
            flex-direction: column;
        }
        .console-header {
            padding: 1rem;
            border-bottom: 1px solid #dbdbdb;
            background: white;
        }
        .console-body {
            flex: 1;
            position: relative;
        }
        .console-canvas {
            width: 100%;
            height: 100%;
            background: #000;
        }
        .status-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <nav class="navbar is-light" role="navigation">
        <div class="navbar-brand">
            <a class="navbar-item" href="/">
                <span class="icon"><i class="fas fa-server"></i></span>
                <strong>PVMSS</strong>
            </a>
        </div>
        <div class="navbar-menu">
            <div class="navbar-start">
                <a class="navbar-item" href="/vm/details/{{.VMID}}">
                    <span class="icon"><i class="fas fa-arrow-left"></i></span>
                    Back to VM Details
                </a>
            </div>
            <div class="navbar-end">
                <div class="navbar-item">
                    <span class="icon"><i class="fas fa-desktop"></i></span>
                    {{.VMName}} ({{.VMID}})
                </div>
            </div>
        </div>
    </nav>

    <div class="console-container">
        <div class="console-header">
            <div class="level">
                <div class="level-left">
                    <div class="level-item">
                        <h1 class="title is-4">VM Console - {{.VMName}}</h1>
                    </div>
                </div>
                <div class="level-right">
                    <div class="level-item">
                        <div class="field is-grouped">
                            <div class="control">
                                <button id="fullscreen-btn" class="button is-small">
                                    <span class="icon"><i class="fas fa-expand"></i></span>
                                    <span>Fullscreen</span>
                                </button>
                            </div>
                            <div class="control">
                                <button id="disconnect-btn" class="button is-small is-danger">
                                    <span class="icon"><i class="fas fa-times"></i></span>
                                    <span>Disconnect</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="console-body">
            <div id="status-indicator" class="status-indicator">
                <span class="tag is-info">Connecting...</span>
            </div>

            <div id="noVNC-container">
                <div id="noVNC_screen">
                    <canvas id="noVNC_canvas" class="console-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script src="/js/crypto-js.min.js"></script>
    <script>
        // VNC Client implementation
        class ConsoleClient {
            constructor(options) {
                this.canvas = options.canvas;
                this.ctx = this.canvas.getContext('2d');
                this.url = options.url;
                this.vncPassword = options.vncPassword || '';
                this.onStatusChange = options.onStatusChange || function() {};
                this.onDisconnect = options.onDisconnect || function() {};
                this.ws = null;
                this.buffer = new Uint8Array(0);
                this.pixelFormat = null;
                this.fbWidth = 0;
                this.fbHeight = 0;
                this.desktopName = '';
                this.connected = false;
                this.queue = []; // Initialize the message queue
                this.state = 'connecting'; // Set initial state
                this.statusElement = options.statusElement;
                console.log('ConsoleClient initialized with URL:', this.url);
            }

            connect() {
                this.updateStatus('Connecting...', 'info');
                try {
                    console.log('Creating WebSocket connection to:', this.url);
                    this.ws = new WebSocket(this.url);
                    this.ws.binaryType = 'arraybuffer';

                    this.ws.onopen = () => {
                        console.log('WebSocket connected. Current state:', this.state);
                        this.updateStatus('Handshaking...', 'info');
                    };

                    this.ws.onmessage = (event) => {
                        if (event.data instanceof ArrayBuffer) {
                            const bytes = new Uint8Array(event.data);
                            this.queue.push(...bytes);
                            this.processVNCMessage();
                        }
                    };

                    this.ws.onclose = (event) => {
                        console.log('WebSocket closed:', event.code, event.reason);
                        if (this.state !== 'disconnected') {
                            this.state = 'disconnected';
                            this.updateStatus('Disconnected', 'danger');
                            this.onDisconnect();
                        }
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        if (this.state !== 'failed') {
                            this.state = 'failed';
                            this.updateStatus('Connection Error', 'danger');
                        }
                    };

                    this.setupInputHandlers();
                } catch (error) {
                    this.state = 'failed';
                    this.updateStatus('Connection Failed', 'danger');
                    console.error('Failed to connect:', error);
                }
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                }
            }

            send(data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(data);
                }
            }

            reverseByte(b) {
                b = ((b & 0xF0) >> 4) | ((b & 0x0F) << 4);
                b = ((b & 0xCC) >> 2) | ((b & 0x33) << 2);
                b = ((b & 0xAA) >> 1) | ((b & 0x55) << 1);
                return b & 0xFF;
            }

            deriveVNCKey(password) {
                let decodedString = atob(password);
                const keyBytes = new Uint8Array(8).fill(0);
                for (let i = 0; i < Math.min(8, decodedString.length); i++) {
                    keyBytes[i] = this.reverseByte(decodedString.charCodeAt(i));
                }
                return CryptoJS.lib.WordArray.create(keyBytes);
            }

            computeVNCAuthResponse(challengeBytes) {
                const key = this.deriveVNCKey(this.vncPassword);
                const challenge = CryptoJS.lib.WordArray.create(challengeBytes);
                const encrypted = CryptoJS.DES.encrypt(challenge, key, {
                    mode: CryptoJS.mode.ECB,
                    padding: CryptoJS.pad.NoPadding
                });
                return this.wordArrayToUint8Array(encrypted.ciphertext);
            }

            wordArrayToUint8Array(wordArray) {
                const len = wordArray.sigBytes;
                const words = wordArray.words;
                const out = new Uint8Array(len);
                let i = 0, j = 0;
                while (i < len) {
                    const w = words[j++];
                    out[i++] = (w >>> 24) & 0xFF;
                    if (i < len) out[i++] = (w >>> 16) & 0xFF;
                    if (i < len) out[i++] = (w >>> 8) & 0xFF;
                    if (i < len) out[i++] = w & 0xFF;
                }
                return out;
            }

            processVNCMessage() {
                let processed = true;
                while (processed) {
                    processed = false;
                    switch (this.state) {
                        case 'connecting':
                            if (this.queue.length >= 12) {
                                const version = String.fromCharCode.apply(null, this.queue.splice(0, 12));
                                this.send(new TextEncoder().encode(version));
                                this.state = 'security';
                                this.updateStatus('Authenticating...', 'info');
                                processed = true;
                            }
                            break;
                        case 'security':
                            if (this.queue.length >= 1) {
                                const numTypes = this.queue.shift();
                                if (this.queue.length >= numTypes) {
                                    const types = this.queue.splice(0, numTypes);
                                    if (types.includes(2)) { // VNC Auth
                                        this.send(new Uint8Array([2]));
                                        this.state = 'authentication';
                                    } else if (types.includes(1)) { // None
                                        this.send(new Uint8Array([1]));
                                        this.state = 'security-result';
                                    } else {
                                        this.disconnect();
                                        return;
                                    }
                                    processed = true;
                                }
                            }
                            break;
                        case 'authentication':
                            if (this.queue.length >= 16) {
                                const challenge = this.queue.splice(0, 16);
                                const response = this.computeVNCAuthResponse(new Uint8Array(challenge));
                                this.send(response);
                                this.state = 'security-result';
                                processed = true;
                            }
                            break;
                        case 'security-result':
                            if (this.queue.length >= 4) {
                                const result = new DataView(new Uint8Array(this.queue.splice(0, 4)).buffer).getUint32(0);
                                if (result === 0) {
                                    this.state = 'client-init';
                                    this.send(new Uint8Array([1])); // Send ClientInit (shared)
                                    this.updateStatus('Initializing...', 'success');
                                } else {
                                    this.updateStatus('Auth Failed', 'danger');
                                    this.disconnect();
                                    return;
                                }
                                processed = true;
                            }
                            break;
                        case 'client-init':
                            if (this.queue.length >= 24) {
                                const header = new DataView(new Uint8Array(this.queue.splice(0, 24)).buffer);
                                this.fbWidth = header.getUint16(0);
                                this.fbHeight = header.getUint16(2);
                                const nameLength = header.getUint32(20);
                                if (this.queue.length >= nameLength) {
                                    this.queue.splice(0, nameLength);
                                    this.canvas.width = this.fbWidth;
                                    this.canvas.height = this.fbHeight;
                                    this.state = 'connected';
                                    this.updateStatus('Connected', 'success');
                                    this.requestFramebufferUpdate(false, 0, 0, this.fbWidth, this.fbHeight);
                                    processed = true;
                                }
                            }
                            break;
                        case 'connected':
                            if (this.queue.length > 0) {
                                const messageType = this.queue.shift();
                                switch (messageType) {
                                    case 0: // FramebufferUpdate
                                        this.handleFramebufferUpdate();
                                        break;
                                }
                                processed = true;
                            }
                            break;
                    }
                }
            }

            handleFramebufferUpdate() {
                if (this.queue.length < 2) return;
                const numRects = new DataView(new Uint8Array(this.queue.splice(0, 2)).buffer).getUint16(0);
                for (let i = 0; i < numRects; i++) {
                    if (this.queue.length < 12) return;
                    const rectHeader = new DataView(new Uint8Array(this.queue.splice(0, 12)).buffer);
                    const x = rectHeader.getUint16(0);
                    const y = rectHeader.getUint16(2);
                    const width = rectHeader.getUint16(4);
                    const height = rectHeader.getUint16(6);
                    const encoding = rectHeader.getInt32(8);
                    if (encoding === 0) { // Raw
                        const size = width * height * 4;
                        if (this.queue.length < size) return;
                        const data = new Uint8Array(this.queue.splice(0, size));
                        this.drawRawRect(x, y, width, height, data);
                    }
                }
                this.requestFramebufferUpdate(true, 0, 0, this.fbWidth, this.fbHeight);
            }

            drawRawRect(x, y, width, height, data) {
                const imageData = this.ctx.createImageData(width, height);
                const canvasData = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    canvasData[i] = data[i+2];
                    canvasData[i+1] = data[i+1];
                    canvasData[i+2] = data[i];
                    canvasData[i+3] = 255;
                }
                this.ctx.putImageData(imageData, x, y);
            }

            requestFramebufferUpdate(incremental, x, y, width, height) {
                const buffer = new ArrayBuffer(10);
                const view = new DataView(buffer);
                view.setUint8(0, 3);
                view.setUint8(1, incremental ? 1 : 0);
                view.setUint16(2, x);
                view.setUint16(4, y);
                view.setUint16(6, width);
                view.setUint16(8, height);
                this.send(buffer);
            }

            setupInputHandlers() {
                this.mouseButtonMask = 0;
                this.canvas.addEventListener('mousedown', (e) => {
                    this.mouseButtonMask |= 1 << e.button;
                    this.sendPointerEvent(e.offsetX, e.offsetY);
                });
                this.canvas.addEventListener('mouseup', (e) => {
                    this.mouseButtonMask &= ~(1 << e.button);
                    this.sendPointerEvent(e.offsetX, e.offsetY);
                });
                this.canvas.addEventListener('mousemove', (e) => this.sendPointerEvent(e.offsetX, e.offsetY));
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                document.addEventListener('keydown', (e) => this.sendKeyEvent(e, true));
                document.addEventListener('keyup', (e) => this.sendKeyEvent(e, false));
            }

            sendPointerEvent(x, y) {
                const buffer = new ArrayBuffer(6);
                const view = new DataView(buffer);
                view.setUint8(0, 5);
                view.setUint8(1, this.mouseButtonMask);
                view.setUint16(2, x);
                view.setUint16(4, y);
                this.send(buffer);
            }

            sendKeyEvent(e, down) {
                const keysym = this.getKeysym(e);
                if (!keysym) return;
                const buffer = new ArrayBuffer(8);
                const view = new DataView(buffer);
                view.setUint8(0, 4);
                view.setUint8(1, down ? 1 : 0);
                view.setUint32(4, keysym);
                this.send(buffer);
            }

            getKeysym(e) {
                if (e.key.length === 1) return e.key.charCodeAt(0);
                const mapping = {
                    'Enter': 0xff0d, 'Backspace': 0xff08, 'Tab': 0xff09,
                    'ShiftLeft': 0xffe1, 'ShiftRight': 0xffe2, 'ControlLeft': 0xffe3, 'ControlRight': 0xffe4,
                    'AltLeft': 0xffe9, 'AltRight': 0xffea, 'Escape': 0xff1b, 'Delete': 0xffff,
                    'Home': 0xff50, 'End': 0xff57, 'ArrowUp': 0xff52, 'ArrowDown': 0xff54,
                    'ArrowLeft': 0xff51, 'ArrowRight': 0xff53, 'PageUp': 0xff55, 'PageDown': 0xff56,
                    'F1': 0xffbe, 'F2': 0xffbf, 'F3': 0xffc0, 'F4': 0xffc1, 'F5': 0xffc2, 'F6': 0xffc3,
                    'F7': 0xffc4, 'F8': 0xffc5, 'F9': 0xffc6, 'F10': 0xffc7, 'F11': 0xffc8, 'F12': 0xffc9
                };
                return mapping[e.code];
            }

            updateStatus(text, type) {
                if (this.statusElement) {
                    this.statusElement.innerHTML = `<span class="tag is-${type}">${text}</span>`;
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('noVNC_canvas');
            const statusEl = document.getElementById('status-indicator');
            if (!canvas) {
                console.error('Canvas element not found!');
                return;
            }

            const vncTicket = '{{.VNCTicket}}';
            const vncPassword = '{{.VNCPassword}}';
            const vmid = '{{.VMID}}';

            // Determine WebSocket scheme (ws/wss) based on the page's protocol.
            const wsScheme = window.location.protocol === "https" ? "wss" : "ws";
            // Construct the WebSocket URL to connect to our backend proxy.
            const wsUrl = `${wsScheme}://${window.location.host}{{.WSProxyURL}}&vncticket=${encodeURIComponent(vncTicket)}`;

            console.log('Connecting to WebSocket:', wsUrl);

            const consoleClient = new ConsoleClient({
                url: wsUrl,
                canvas: canvas,
                statusElement: statusEl,
                vncPassword: vncPassword,
                onDisconnect: () => {
                    setTimeout(() => window.location.href = `/vm/details/${vmid}`, 1000);
                }
            });

            consoleClient.connect();

            document.getElementById('fullscreen-btn').addEventListener('click', () => {
                canvas.requestFullscreen();
            });

            document.getElementById('disconnect-btn').addEventListener('click', () => {
                consoleClient.disconnect();
            });

            window.addEventListener('beforeunload', () => {
                consoleClient.disconnect();
            });
        });
    </script>
</body>
</html>
{{end}}
